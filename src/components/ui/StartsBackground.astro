---

---

<canvas id="particle-canvas" class="fixed inset-0 w-full h-full -z-10"></canvas>

<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

  function initStarField() {
    const canvas = document.getElementById(
      "particle-canvas",
    ) as HTMLCanvasElement;
    if (!canvas) return;

    const scene = new THREE.Scene();

    // Set background to softBeige
    const softBeigeColor = new THREE.Color(0xf6f4f1); // softBeige: oklch(0.9643 0.007 88.64)
    scene.fog = new THREE.Fog(softBeigeColor, 50, 200);
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000,
    );
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xf6f4f1, 1); // softBeige background

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Design system colors (converted from OKLCH to approximate hex)
    const colors = {
      softWhite: 0xfefefe, // oklch(0.997 0 0)
      accentGold: 0xf4d03f, // oklch(0.8987 0.119 87.54)
      softLavender: 0xb19cd9, // oklch(0.8166 0.0659 291.7)
      salviaGreen: 0xa8c98a, // oklch(0.761 0.0408 138.18)
      accentGreen: 0x4a9b8e, // oklch(0.5366 0.081 179.54)
      sandRose: 0xd4a574, // oklch(0.7638 0.0655 28.26)
    };

    // Create 2D star texture
    function createStarTexture() {
      const canvas = document.createElement("canvas");
      const size = 64;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      if (!ctx) return new THREE.CanvasTexture(canvas);

      // Clear canvas with transparent background
      ctx.clearRect(0, 0, size, size);

      // Draw 4-pointed star in white (will be tinted by material color)
      ctx.fillStyle = "white";
      ctx.beginPath();

      const centerX = size / 2;
      const centerY = size / 2;
      const outerRadius = size * 0.4;
      const innerRadius = size * 0.15;
      const spikes = 4;

      let angle = (Math.PI / 2) * 3;
      const step = Math.PI / spikes;

      ctx.moveTo(centerX, centerY - outerRadius);

      for (let i = 0; i < spikes; i++) {
        ctx.lineTo(
          centerX + Math.cos(angle) * outerRadius,
          centerY + Math.sin(angle) * outerRadius,
        );
        angle += step;
        ctx.lineTo(
          centerX + Math.cos(angle) * innerRadius,
          centerY + Math.sin(angle) * innerRadius,
        );
        angle += step;
      }

      ctx.closePath();
      ctx.fill();

      return new THREE.CanvasTexture(canvas);
    }

    const starTexture = createStarTexture();

    // Create instanced stars with varied colors and positions
    const starCount = 300;

    const starField = new THREE.Group();

    for (let i = 0; i < starCount; i++) {
      // Use accentGold color for all stars
      const color = new THREE.Color(colors.accentGold);

      const starMaterial = new THREE.SpriteMaterial({
        map: starTexture,
        color: color,
        transparent: true,
        opacity: Math.random() * 0.8 + 0.2,
      });

      const star = new THREE.Sprite(starMaterial);

      // Random position
      star.position.set(
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
        (Math.random() - 0.5) * 200,
      );

      // Random size - made stars bigger
      const scale = Math.random() * 1.5 + 0.5; // Increased from 0.8+0.2 to 2.5+1.0
      star.scale.setScalar(scale);

      // Store animation data
      star.userData = {
        baseScale: scale,
        pingPhase: Math.random() * Math.PI * 2, // Random starting phase
        pingSpeed: 0.5 + Math.random() * 1.5, // Random ping speed
        pingIntensity: 0.3 + Math.random() * 0.4, // Random ping strength
        lastPing: Math.random() * 10000, // Random initial ping timing
      };

      starField.add(star);
    }

    scene.add(starField);

    // Controls (optional, for exploring the scene)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;

    // Animation loop with enhanced effects
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // Rotate the entire star field
      starField.rotation.y += 0.0003;
      starField.rotation.x += 0.0001;

      // Individual star animations
      starField.children.forEach((star) => {
        const sprite = star as THREE.Sprite;
        const userData = sprite.userData;
        if (!userData) return;

        // Ping animation effect
        const timeSinceLastPing = time - userData.lastPing;

        // Trigger ping every 3-8 seconds randomly
        if (timeSinceLastPing > 3 + Math.random() * 5) {
          userData.lastPing = time;
        }

        // Calculate ping effect (sharp rise, gradual fall)
        let pingFactor = 1;
        if (timeSinceLastPing < 1) {
          // Ping lasts 1 second
          const pingProgress = timeSinceLastPing;
          // Create a sharp ping effect that fades out
          pingFactor =
            1 +
            userData.pingIntensity *
              Math.exp(-pingProgress * 4) *
              Math.cos(pingProgress * 8);
        }

        // Subtle continuous pulsing
        const basePulseFactor =
          Math.sin(time * userData.pingSpeed + userData.pingPhase) * 0.05 + 1;

        // Combine ping and pulse effects
        const finalScale = userData.baseScale * pingFactor * basePulseFactor;
        sprite.scale.setScalar(finalScale);

        // Ping opacity effect
        const opacityPing =
          timeSinceLastPing < 1 ? Math.exp(-timeSinceLastPing * 3) * 0.3 : 0;
        sprite.material.opacity = Math.min(
          1,
          sprite.material.opacity + opacityPing,
        );
      });

      // Subtle camera movement
      camera.position.x = Math.sin(time * 0.1) * 0.5;
      camera.position.y = Math.cos(time * 0.15) * 0.3;

      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  }

  initStarField();
</script>
